# Agent Rules

The following are _strict rules_ that all Agents (User Agents and Special Agents) must follow and to which all submissions to the project must adhere. These are numbered, so that specific "laws" can be referenced by number.

**Relationship to Design-Decisions.md**: This document governs agent *behavior* (formatting, forbidden actions, evergreen standards). For project-specific *design philosophies* (how the product should be built), see `docs/core/Design-Decisions.md`. Both documents work together: Agent-Rules tells agents how to work; Design-Decisions tells agents how to build this specific project.

## 1. Software Engineering Principles

The following are time-tested software engineering principles that should guide our work:

- **1.1** SOLID - An acronym for five object-oriented design principles, SOLID helps developers create more understandable, flexible, and maintainable software.
  - **1.1.1** S - Single Responsibility Principle (SRP): A class should have only one reason to change, meaning it should have only one job. This makes the code easier to understand and modify.
  - **1.1.2** O - Open/Closed Principle (OCP): Software entities should be open for extension but closed for modification.
  - **1.1.3** L - Liskov Substitution Principle (LSP): Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.
  - **1.1.4** I - Interface Segregation Principle (ISP): A client should not be forced to depend on interfaces it does not use.
  - **1.1.5** D - Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules; both should depend on abstractions.
- **1.2** DRY - Don't Repeat Yourself. This principle aims to reduce the repetition of information. By avoiding repetition, you can keep your codebase smaller, more manageable, and easier to maintain.
- **1.3** KISS - Keep It Simple, Stupid. This principle emphasizes that systems work best if they are kept simple rather than made complicated. Simplicity makes code easier to maintain, test, and understand.
- **1.4** YAGNI - You Aren't Gonna Need It. This principle states that you should not add functionality until you need it. It aims to avoid the complexity that arises from adding functionality you expect you may need in the future. Agents have a tendency to hallucinate superfluous requirements, so ensure everything you add must be necessary. Important Note: YAGNI applies to implementation, not planning - do not cancel (mark `[-]`) items in the Action Plan simply because you aren't doing them _yet_.
- **1.5** - Trust Documented Guarantees. When an authoritative component documents a guarantee about data it provides (e.g., "get_effective_config() returns all defaults from get_default_config()"), consuming code should trust that guarantee and not add redundant defensive fallbacks. Before adding fallback defaults in patterns like `.get(key, default)`, verify whether an upstream source already guarantees the value exists. Redundant fallbacks violate DRY and create multiple sources of truth.

## 2. Forbidden File Edits and Commands

The following are forbidden actions for the User Agent and all Special Agents:

- **2.1** Do not edit any files in the following folders:
  - **2.1.1** `dev/template/`, if it exists.
  - **2.1.2** `docs/read-only/`. You may read these files, but do not edit them.
  - **2.1.3** `docs/references/`. You may read these files, but do not edit them.
  - **2.1.4** `docs/reports/`. These are generated by tools and are not to be manually updated.
  - **2.1.5** `dev/worksbench/`. This folder should not exist - you have confused it with `docs/workbench/`.
  - **2.1.6** `.env` file. Make your edits to `.env.example` files instead.
- **2.2** Do not run any `git` command that modifies repository state. This is a **strict whitelist** - if a command is not explicitly listed below, it is FORBIDDEN.
  - **2.2.1** **PERMITTED git commands (exhaustive whitelist):**
    - **Status and Inspection:** `git status`, `git diff`, `git log`, `git show`, `git reflog`, `git shortlog`, `git whatchanged`
    - **File and Tree Queries:** `git ls-files`, `git ls-tree`, `git cat-file`, `git diff-tree`, `git diff-files`
    - **History and Blame:** `git blame`, `git annotate`
    - **Search:** `git grep`
    - **Branch and Reference Queries:** `git branch` (list only), `git show-ref`, `git rev-parse`, `git name-rev`, `git describe`, `git for-each-ref`
    - **Configuration Queries:** `git config` (read operations only: `--get`, `--list`, or querying a key), `git remote -v`
    - **Repository Information:** `git count-objects`, `git fsck`, `git verify-commit`, `git verify-tag`
    - **Stash Queries:** `git stash list`, `git stash show`
  - **2.2.2** **FORBIDDEN git commands (any command NOT in the whitelist above).** This includes but is not limited to: `git stash` (except list/show), `git add`, `git commit`, `git checkout`, `git switch`, `git reset`, `git clean`, `git push`, `git pull`, `git fetch`, `git merge`, `git rebase`, `git cherry-pick`, `git revert`, `git rm`, `git mv`, `git tag`, `git branch -d/-D/-m/-M`, `git config --set/--unset/--add`, `git remote add/remove`.
  - **2.2.3** **If you believe you need to modify repository state** (e.g., "I need to stash uncommitted changes"), this indicates an environmental issue - escalate to the User rather than attempting any state-modifying command.

Note to Rules-Enforcer agent: Forbidden directories specify a specific path; just because a specific forbidden directory is called `dev/template/` doesn't mean that no other directory called `template` can be created or edited elsewhere in the project.

## 3. General Agent Behavior

These are rules that govern general agent behavior and include more "evergreen" instructions that should apply regardless of the specific AI model used:

- **3.1.** Think carefully and only act on the specific task you have been assigned with the most concise and elegant solution that changes as little code as possible.
- **3.2** - When you are asked to add logs for debugging, add a prefix marker with a unique identifier to all log messages so that the debugging of the current feature can be easily tracked in the logs and the messages can be later easily muted. For example, if we're having trouble with capturing a keyboard event across a transition, compose your debug logs with something like "[KB_CAPTURE]" (e.g., "[KB_CAPTURE] The keypress was detected", "[KB_CAPTURE] Key release event detected").
- **3.3** When writing specs and design documents (`.md` files), prefer a paragraph-style of writing in Markdown, but use lists where applicable.
- **3.4** - Do not include meta-process references in **product artifacts**. This rule protects our finished product from containing ephemeral planning details that have no meaning outside the development process.
  - **3.4.1** **Product Artifacts** (Rule 3.4 APPLIES): Source code files, test files, scripts, configuration files, and any file that will be deployed or shipped. These must never contain phase numbers, task references, or other planning artifacts.
  - **3.4.2** **Process Documents** (Rule 3.4 does NOT apply): Feature Overview specs (including their FIPs), tickets, Action Plans, workbench documents, and any file whose purpose is to coordinate development work. These documents SHOULD contain phase numbers, task references, and checkboxlists - that is their purpose.
  - **3.4.3** **Examples of Violations** (in product artifacts):
    - `# Extracted from cli.py during Phase 2 refactoring` - BAD COMMENT
    - `# Logs warnings for malformed tags (task 2.5.4)` - BAD COMMENT
    - `"""Test for Phase 3 authentication feature"""` - BAD DOCSTRING
    - `// Fixed null pointer (see ticket #47)` - BAD COMMENT
  - **3.4.4** **Examples of Correct Usage** (in process documents):
    - FIP in Feature Overview with `### Phase 1: Implementation` - CORRECT
    - Ticket checkboxlist with `- [ ] **2.3.1** - Add validation` - CORRECT
    - Action Plan with phase-organized tasks - CORRECT
  - **3.4.5** **Rule-Enforcer Guidance**: When reviewing for Rule 3.4 violations, first determine if the file is a product artifact or a process document. Only flag violations in product artifacts. Never demand removal of phase numbers or task references from Feature Specs, tickets, Action Plans, or other planning documents - these elements are essential to their function.
- **3.5** - When making code changes, specification documents must be updated to match the implementation. If a feature is added, removed, or modified, the corresponding specification file must be updated in the same workscope. Specifications serve as the source of truth for how the system should work, and they must remain synchronized with the actual code. This especially includes files in `docs/core/` and any feature-specific specification documents in `docs/features/`. Failing to update specifications when changing code is a critical violation that creates specification drift and undermines the reliability of the project's documentation. Discrepancies between specification and implementation are not acceptable. Fixes to detected spec drift are not "optional"; it is imperative that our documentation and implementation align.
- **3.6** - When creating or editing a **checkboxlist**, remember that a checkboxlist is a cohesive task list. It should not be interrupted by context regarding the tasks, which should exist separately elsewhere in the file that contains the checkboxlist. This cohesiveness is necessary for the Task-Master Agent to parse and select workscopes.
- **3.7** - Before adding defensive fallbacks, ask: "What guarantees can I rely on?" When accessing data from an authoritative component, first check what it guarantees about return values. If it guarantees the data will be present, adding a fallback duplicates that guarantee and violates DRY.
- **3.8** - Use the system's `date` command in terminal to find the current date. This is the Source of Truth for the current date and time, regardless of whether it matches with your current belief.
- **3.9** - You may be requested to perform an investigation or audit. The User wishes to examine and discuss the details of your findings and potential solutions before you proceed to implement what you think is the proper solution. Watch for the "Engage!" directive.
- **3.10** - You may be requested to write a feature specification. Creating a specification document means ONLY creating that document, not implementing any code described in it.
- **3.11** - If you need to edit a file but get an error preventing write access (due to its location in a read-only directory like `docs/read-only/` or `.claude/`, among others), copy that file to docs/workbench/ keeping the exact same filename, then make your edits directly to this workbench copy as if you were editing the original file. Do not add any annotations, meta-information, or filename suffixes - simply edit the copy cleanly and inform the User that you've created an edited version in workbench for their review.
- **3.12** - Do NOT ACCEPT Special Agent reports if they do not provide the proper proof of work.
- **3.13** - The `dev/reports` directory is for human-readable API documentation generated via common developer tools (e.g., pdoc, typedoc). The `docs/reports` directory is for AI-tailored documentation via custom tools.
- **3.14** - When specifications include code examples, those examples are prescriptive, not illustrative. Parameter names, function signatures, and variable names in specs are requirements, not suggestions.
- **3.15** - If issues are discovered, you MUST escalate to the User. "It's not part of my workscope" is not an excuse to ignore problems. You may have exposed a true underlying bug in the code or the project's design, and it needs to be addressed. Pre-existing problems may be excusable during QA checks, but it doesn't excuse the need to at least inform the User.
- **3.16** - You are the User's eyes and ears. The User has no visibility into your conversations with Special Agents or tool outputs. All discoveries—issues, warnings, anomalies, concerns raised by any agent—must be reported to the User. "Not my workscope" determines what you must *fix*, not what you must *report*. Information that dies with your session is information lost forever.
- **3.17** - Tool exceptions (e.g., "# noqa: ") MUST BE APPROVED by the User before they are added to any code. Our goal isn't to simply pass health checks; it's to write good code. We don't resolve issues by sweeping them under the rug or hiding them.
- **3.18** - If your tasks are only to write tests, then you should **only write tests**, not presume that you should update the source code such that the tests pass. There may be times (such as in TDD processes) in which tests are expected to fail when initially written.
- **3.19** - If your task is to write a test, and you find after implementing it that there is a fault in the implementation that causes your test to fail, do not update your test to align with the faulty (current) implementation. To do so would defeat the entire purpose of writing tests. I can't believe this actually had to be made an explicit rule.
- **3.20** - Distinguish between failure types in multi-phase work:
  - **In-Flight Failure (IFF)**: A test failure or issue caused by earlier phases of the current ticket/feature that is scheduled for resolution in a later phase of the SAME ticket. IFFs are expected during mid-ticket workscopes and are NOT bugs—they are planned consequences of phased work.
  - **Pre-Existing Failure**: An issue that existed BEFORE the current ticket/feature began and is completely unrelated to the current work arc.

  The phrase "pre-existing" must NEVER be used to describe issues introduced by earlier phases of the same ticket. Those are "in-flight failures" (IFFs). Using "pre-existing" to describe IFFs is a terminology violation that obscures accountability. When encountering test failures during QA, agents must categorize each failure as: (a) **INTRODUCED** - caused by the current workscope's changes, (b) **IFF** - caused by earlier phases of this ticket, scheduled for later resolution, or (c) **PRE-EXISTING** - existed before this ticket began, unrelated to current work.

## 4. LLM Model-Specific Quirks

These are rules that provide workarounds for behaviors of specific AI models, allowing them to be easily swapped out when models are switched or new models are released.

<WORKSCOPE-DEV agent-model-quirks>

[Claude **Opus 4.5** & **Sonnet 4.5**]
- **4.1** DO NOT CREATE TEMPORARY FILES IN THE PROJECT ROOT, failing to properly place diagnostic temporary files in the `dev/diagnostics` folder is a critical rule violation.
  - **4.1.1** If creating a "diagnostic" artifact--e.g., a Markdown file, shell script, or quick (Python, Node.js) tool to debug or investigate a particular issue, but one that is not expected to be part of the project--please create it in the `dev/diagnostics` folder
  - **4.1.2** Do not remove files from the `dev/diagnostics` folder after the issue is resolved (we may need it again).
- **4.2** When given a file to read, READ THE ENTIRE FILE UNLESS OTHERWISE DIRECTED. If you have to read it in chunks, do so, but do not stop until you have read the entire file. To fail to do so is a critical rule violation.
- **4.3** When creating random files, prefer using something like `openssl rand -base64 1200000 > large_file.txt` to generate the files instead of simply printing a line repeatedly in a loop.
- **4.4** - `cat >> file << EOF` is FORBIDDEN. Do NOT use terminal commands (such as `cat` or `echo` with `>>`, etc.) to write to files. Use your standard tools (e.g., Read, Edit, etc.) to interact with files throughout your session. Creating any of these patterns should trigger an IMMEDIATE RED FLAG: `cat >>`, `echo >>`, `<< EOF`, `> file`, `>> file`. These should be considered syntax errors.
- **4.5** - If you cannot read a file, try at least one more time before escalating to the User. Your read tools can be inconsistent or momentarily unreliable. Attempt to `ls` to identify that the file exists and attempt a second read before you waste the User's time claiming that a file doesn't exist.
- **4.6** - When escalating an issue to the User (e.g., after facing rejection from a Special Agent, when facing a difficulty with a tool, etc.), present the issue in full detail. Do not presume that the User has seen the output of the tool or observed the response of the Special Agent. The User does not have the same visibility into every process that you do. Recap the issue and provide details so the User can make an informed decision.
- **4.7** - Own your warnings. If your work introduces a warning—even a "non-blocking" one—you are responsible for resolving it before completing your workscope. "Non-blocking" means the build doesn't fail; it does not mean you can ignore it. For each warning, determine: Is it a real problem you introduced? Fix it. Is it expected behavior per specification? Document why and confirm with the User. Is it a tool misconfiguration? Address it. Do not complete your workscope with unresolved warnings you caused.
- **4.8** - Follow the User's lead, not your workscope's boundaries. When the User asks you to investigate something further, expand your scope, or pursue an emerging issue—do it. Your workscope defines your starting assignment, not your permitted actions. If investigation reveals a significant problem (specification drift, systemic bug, architectural flaw), report it clearly and propose next steps. Do not insist on closing your workscope when the User wants to dig deeper. Quality and correctness take priority over workscope completion.
- **4.9** - Report all QA discoveries to the User. When a Special Agent raises any issue, warning, or concern—even if unrelated to your workscope, even if "non-blocking," even if they ultimately approve—you must report it in your USER ACTION ITEMS. The User starts from a clean codebase and runs sequential workscopes; any finding is either something you introduced or a rare detection of a latent bug. Either way, the User needs to know immediately. Silently dismissing QA discoveries because "it's not my problem" is a critical violation.
- **4.10** - When writing tests that patch module-level constants (like `PROJECT_ROOT`), identify and patch ALL derived constants in the dependency chain. Python evaluates expressions like `REPORTS_DIR = PROJECT_ROOT / "docs"` once at import time, creating snapshots—patching the base constant later does not update constants derived from it. Before writing a test that patches any path constant, grep the module for other constants that reference it and patch those too.

</WORKSCOPE-DEV>

## 5. Pre-Release Rules

The following are rules that are applicable before the project has shipped to regulate the AI's eagerness to defensively support previous designs (even when the design itself is in flux). After shipping, these rules can be swapped out.

<WORKSCOPE-DEV agent-rules-pre-release>

- **5.1** THIS APP HAS NOT SHIPPED YET. When we make a change, please do not include migration-based solutions or be concerned with maintaining "backward compatibility" or "legacy support." DO NOT BE CONCERNED WITH BACKWARD COMPATIBILITY. You will try to side-step this and sneak around it. You will try to say that it was just an "informal migration note" that only existed in documentation, not code. YOU HAVE FAILED. REJECTION.
- **5.2** Refactors should be performed such that the codebase does not reference the old design. These represent small violations of Rule 5.1:
  - Example 1: If extracting Component A from within Component B, there should not be a ❌ "verify_component_a_refactor.py" test suite. Instead, there should be tests covering Component A and tests covering Component B in their new design as if they had always been designed that way.
  - Example 2: There should be no comments acknowledging the old design, such as ❌ "# Note: Must use EnvManager.load_env since config.get_api_key() now uses EnvManager".
  - Example 3: There should be no comments noting that something was removed or refactored, such as ❌ "# File services have been moved to the ProjectManager component" or ❌ "# Now uses external library for regex"

</WORKSCOPE-DEV>

## 6. Project-Specific Rules

The following are rules pertaining to this specific project:

<WORKSCOPE-DEV agent-rules-project-specific>

</WORKSCOPE-DEV>
