     1â†’#!/usr/bin/env python
     2â†’"""Workscope-Dev Runner (wsd.py) - Unified task runner for all Workscope-Dev projects.
     3â†’
     4â†’This script provides a consistent command-line interface across Python, TypeScript,
     5â†’JavaScript, and mixed-language projects. Commands like `ws test`, `ws lint`, and
     6â†’`ws format` work identically regardless of the underlying technology stack, with
     7â†’the runner transparently mapping to appropriate tools.
     8â†’
     9â†’Core Philosophy:
    10â†’- Command homogenization: Same commands work everywhere
    11â†’- Project type auto-detection: No manual configuration needed
    12â†’- Universal coverage: 29 commands covering common development tasks
    13â†’- Workscope-Dev integration: Core workflow commands always available
    14â†’
    15â†’Usage:
    16â†’    ./wsd.py <command> [args...]
    17â†’    python wsd.py <command> [args...]
    18â†’
    19â†’Script-Level Flags:
    20â†’    --help, -h      Display all available commands and exit
    21â†’    --version, -V   Display WSD version and exit
    22â†’
    23â†’Examples:
    24â†’    ./wsd.py test           # Runs pytest or jest based on project type
    25â†’    ./wsd.py lint           # Runs ruff or eslint based on project type
    26â†’    ./wsd.py health         # Runs Workscope-Dev health check
    27â†’    ./wsd.py health:clean   # Health check with fresh cache (deterministic)
    28â†’    ./wsd.py                # Shows all available commands
    29â†’    ./wsd.py --version      # Shows WSD version
    30â†’
    31â†’For shell convenience, create an alias:
    32â†’    alias wsd='./wsd.py'
    33â†’"""
    34â†’
    35â†’import datetime
    36â†’import errno
    37â†’import json
    38â†’import logging
    39â†’import os
    40â†’import re
    41â†’import shutil
    42â†’import subprocess
    43â†’import sys
    44â†’from dataclasses import dataclass
    45â†’from pathlib import Path
    46â†’from typing import Any, NoReturn
    47â†’
    48â†’
    49â†’# Import language detection utilities from scripts directory
    50â†’_scripts_dir = Path(__file__).parent / "scripts"
    51â†’sys.path.insert(0, str(_scripts_dir))
    52â†’from wsd_utils import (  # noqa: E402
    53â†’    WsdCollectionError,
    54â†’    _is_binary_file,
    55â†’    calculate_file_hash,
    56â†’    collect_wsd_files,
    57â†’    detect_package_manager,
    58â†’    detect_project_languages,
    59â†’)
    60â†’
    61â†’
    62â†’# Configure logging for tag preservation warnings and verbose output
    63â†’logger = logging.getLogger(__name__)
    64â†’
    65â†’# Global verbose flag for detailed operation logging
    66â†’_verbose_mode = False
    67â†’
    68â†’
    69â†’def set_verbose_mode(enabled: bool) -> None:
    70â†’    """Enable or disable verbose output mode.
    71â†’
    72â†’    When verbose mode is enabled, detailed operation logging is printed
    73â†’    to stderr to help users troubleshoot installation and update issues.
    74â†’
    75â†’    Args:
    76â†’        enabled: True to enable verbose output, False to disable
    77â†’    """
    78â†’    global _verbose_mode  # noqa: PLW0603
    79â†’    _verbose_mode = enabled
    80â†’    if enabled:
    81â†’        # Configure logging to show INFO level messages
    82â†’        logging.basicConfig(
    83â†’            level=logging.INFO,
    84â†’            format="[VERBOSE] %(message)s",
    85â†’            stream=sys.stderr,
    86â†’        )
    87â†’
    88â†’
    89â†’def verbose_log(message: str) -> None:
    90â†’    """Log a message if verbose mode is enabled.
    91â†’
    92â†’    Prints detailed operation information to stderr when verbose mode
    93â†’    is active. Messages are prefixed with [VERBOSE] for easy filtering.
    94â†’
    95â†’    Args:
    96â†’        message: The message to log
    97â†’    """
    98â†’    if _verbose_mode:
    99â†’        print(f"[VERBOSE] {message}", file=sys.stderr)
   100â†’
   101â†’
   102â†’# Type alias for command structures
   103â†’Command = list[str] | list[list[str]]
   104â†’
   105â†’
   106â†’def cmd(*args: str) -> list[str]:
   107â†’    """Build a command array from arguments.
   108â†’
   109â†’    Args:
   110â†’        *args: Command components as strings
   111â†’
   112â†’    Returns:
   113â†’        list[str]: Command array suitable for subprocess.run()
   114â†’    """
   115â†’    return list(args)
   116â†’
   117â†’
   118â†’def lang_cmd(python_cmd: list[str], node_cmd: list[str]) -> list[str]:
   119â†’    """Return appropriate command based on detected project type.
   120â†’
   121â†’    This function enables command homogenization by selecting the
   122â†’    language-appropriate implementation at runtime. Uses detect_project_languages()
   123â†’    internally, prioritizing Node.js languages when multiple languages detected.
   124â†’
   125â†’    Args:
   126â†’        python_cmd: Command to use for Python projects.
   127â†’        node_cmd: Command to use for Node.js projects (TypeScript and JavaScript).
   128â†’
   129â†’    Returns:
   130â†’        Command array for the detected project type, or warning message if no
   131â†’        languages detected. Node.js languages take priority in multi-language projects.
   132â†’    """
   133â†’    languages = detect_project_languages()
   134â†’
   135â†’    # Node.js languages (TypeScript/JavaScript) take priority in multi-language projects
   136â†’    if "typescript" in languages or "javascript" in languages:
   137â†’        return node_cmd
   138â†’    if "python" in languages:
   139â†’        return python_cmd
   140â†’    # No languages detected - return helpful warning
   141â†’    warning = "âš ï¸  No languages detected. Add pyproject.toml or package.json to enable task runner."
   142â†’    return cmd("echo", warning)
   143â†’
   144â†’
   145â†’def multi_lang_cmd(
   146â†’    python_cmd: list[str] | None = None, node_cmd: list[str] | None = None
   147â†’) -> list[list[str]]:
   148â†’    """Return commands for all detected project languages.
   149â†’
   150â†’    This function enables multi-language command execution by returning
   151â†’    commands for each detected language in the project. Commands execute
   152â†’    sequentially (Python first, then Node.js) with fail-fast behavior.
   153â†’
   154â†’    Args:
   155â†’        python_cmd: Command to use for Python. None to skip Python even if detected.
   156â†’        node_cmd: Command to use for Node.js projects (TypeScript and JavaScript).
   157â†’                  None to skip Node.js languages even if detected.
   158â†’
   159â†’    Returns:
   160â†’        List of command arrays, one per detected language. Returns warning command
   161â†’        if no languages detected or all language commands are None. Empty list never
   162â†’        returned - always at least one command (may be warning message).
   163â†’    """
   164â†’    languages = detect_project_languages()
   165â†’    commands = []
   166â†’
   167â†’    # Build commands for detected languages (Python first, then Node.js)
   168â†’    if "python" in languages and python_cmd is not None:
   169â†’        commands.append(python_cmd)
   170â†’
   171â†’    # Both TypeScript and JavaScript use the same Node.js tooling
   172â†’    if ("typescript" in languages or "javascript" in languages) and node_cmd is not None:
   173â†’        commands.append(node_cmd)
   174â†’
   175â†’    # No valid commands - return warning
   176â†’    if not commands:
   177â†’        warning = (
   178â†’            "âš ï¸  No languages detected. Add pyproject.toml or package.json to enable task runner."
   179â†’        )
   180â†’        commands.append(cmd("echo", warning))
   181â†’
   182â†’    return commands
   183â†’
   184â†’
   185â†’def execute_multi_lang_task(
   186â†’    _task_name: str, commands: list[list[str]], extra_args: list[str]
   187â†’) -> int:
   188â†’    """Execute commands for multiple languages sequentially with fail-fast behavior.
   189â†’
   190â†’    Validates that all command components are strings before execution. If any
   191â†’    command contains None (indicating a missing package manager), prints an error
   192â†’    with installation instructions and returns exit code 1.
   193â†’
   194â†’    Args:
   195â†’        _task_name: Name of the task being executed (reserved for future use)
   196â†’        commands: List of commands to execute (one per language)
   197â†’        extra_args: Additional arguments to forward to each command
   198â†’
   199â†’    Returns:
   200â†’        int: Exit code - 0 for success, 1 for missing package manager,
   201â†’            or non-zero from first failing command
   202â†’    """
   203â†’    for command in commands:
   204â†’        # Validate command components - check for None values indicating
   205â†’        # a missing package manager (PKG_MANAGER is None for Node.js projects
   206â†’        # without a lock file)
   207â†’        if any(arg is None for arg in command):
   208â†’            _exit_missing_package_manager()
   209â†’
   210â†’        # Build complete command with extra arguments
   211â†’        full_command = command + extra_args
   212â†’
   213â†’        # Run the command
   214â†’        print(f"ğŸš€ Running: {' '.join(full_command)}")
   215â†’        print("-" * 70)
   216â†’        result = subprocess.run(full_command, check=False)
   217â†’
   218â†’        # Fail-fast: return immediately on first failure
   219â†’        if result.returncode != 0:
   220â†’            return result.returncode
   221â†’
   222â†’    # All commands succeeded
   223â†’    return 0
   224â†’
   225â†’
   226â†’def get_check_dirs() -> list[str]:
   227â†’    """Read check directories from pyproject.toml [tool.wsd] configuration.
   228â†’
   229â†’    Lazy-loaded only when config-dependent commands (lint, format, type, security)
   230â†’    are executed. Uses tomllib (Python 3.11+) or tomli fallback for parsing.
   231â†’
   232â†’    Returns:
   233â†’        List of directory paths to check (e.g., ["src", "tests"]). Can be empty list.
   234â†’
   235â†’    Raises:
   236â†’        SystemExit: With code 1 if pyproject.toml or [tool.wsd] configuration is missing
   237â†’            or if check_dirs is not a list type.
   238â†’    """
   239â†’    # Lazy import - only load when config needed
   240â†’    try:
   241â†’        import tomllib  # type: ignore[import-not-found]  # noqa: PLC0415
   242â†’    except ModuleNotFoundError:
   243â†’        import tomli as tomllib  # noqa: PLC0415
   244â†’
   245â†’    pyproject_path = Path("pyproject.toml")
   246â†’
   247â†’    # Validate pyproject.toml exists
   248â†’    if not pyproject_path.exists():
   249â†’        print("âŒ ERROR: pyproject.toml not found in project root.", file=sys.stderr)
   250â†’        print(
   251â†’            "\nWorkscope-Dev requires pyproject.toml with [tool.wsd] configuration.",
   252â†’            file=sys.stderr,
   253â†’        )
   254â†’        print("\nAdd this to your pyproject.toml:", file=sys.stderr)
   255â†’        print("\n[tool.wsd]", file=sys.stderr)
   256â†’        print('check_dirs = ["src", "tests"]', file=sys.stderr)
   257â†’        sys.exit(1)
   258â†’
   259â†’    # Parse TOML file
   260â†’    try:
   261â†’        with pyproject_path.open("rb") as f:
   262â†’            config = tomllib.load(f)
   263â†’    except Exception as e:
   264â†’        print(f"âŒ ERROR: Failed to parse pyproject.toml: {e}", file=sys.stderr)
   265â†’        print("\nEnsure your pyproject.toml is valid TOML format.", file=sys.stderr)
   266â†’        sys.exit(1)
   267â†’
   268â†’    # Extract [tool.wsd] configuration
   269â†’    wsd_config = config.get("tool", {}).get("wsd", {})
   270â†’
   271â†’    # Validate configuration exists
   272â†’    if not wsd_config or "check_dirs" not in wsd_config:
   273â†’        print(
   274â†’            "âŒ ERROR: [tool.wsd] configuration missing or incomplete in pyproject.toml.",
   275â†’            file=sys.stderr,
   276â†’        )
   277â†’        print("\nAdd this to your pyproject.toml:", file=sys.stderr)
   278â†’        print("\n[tool.wsd]", file=sys.stderr)
   279â†’        print('check_dirs = ["src", "tests"]', file=sys.stderr)
   280â†’        print("\nFor config-dependent commands (lint, format, type, security).", file=sys.stderr)
   281â†’        sys.exit(1)
   282â†’
   283â†’    # Validate check_dirs type
   284â†’    check_dirs = wsd_config["check_dirs"]
   285â†’    if not isinstance(check_dirs, list):
   286â†’        print("âŒ ERROR: check_dirs must be a list in pyproject.toml", file=sys.stderr)
   287â†’        print('\nExample: check_dirs = ["src", "tests"]', file=sys.stderr)
   288â†’        sys.exit(1)
   289â†’    return check_dirs
   290â†’
   291â†’
   292â†’# Detect project context
   293â†’PROJECT_LANGUAGES = detect_project_languages()
   294â†’# Detect package manager for Node.js projects (both TypeScript and JavaScript)
   295â†’PKG_MANAGER = (
   296â†’    detect_package_manager()
   297â†’    if ("typescript" in PROJECT_LANGUAGES or "javascript" in PROJECT_LANGUAGES)
   298â†’    else None
   299â†’)
   300â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
